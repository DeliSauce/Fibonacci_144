{"version":3,"sources":["webpack:///webpack/bootstrap 8fe7010a9e640ff496f6","webpack:///./lib/game.js","webpack:///./lib/block.js","webpack:///./lib/main.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,eAAe;AACjC,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA,qBAAqB,eAAe;AACpC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,eAAe;AAClC,qBAAqB,eAAe;;AAEpC;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,eAAe;AACpC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,eAAe;AAClC,qBAAqB,eAAe;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,eAAe;AAClC,qBAAqB,eAAe;;AAEpC;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;;;;;AChdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzCA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8fe7010a9e640ff496f6","const Block = require(\"./block\");\n\nconst FIBONACCI = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];\n\n\nclass Game {\n  constructor(size, startSequence, ctx, boardWidth) {\n    this.size = parseInt(size);\n    this.startSequence = parseInt(startSequence);\n    this.over = false;\n    this.ctx = ctx;\n    this.boardWidth = boardWidth;\n    this.borderWidth = 15;\n    this.blockWidth = (boardWidth - (this.size + 1) * this.borderWidth)/size;\n    this.board = this.setupBoard();\n    this.sequence = FIBONACCI.slice(this.startSequence);\n\n    this.allowUserInput = true;\n    this.slidingAnimation = false;\n    this.collisionAnimation = false;\n    this.randomAnimation = false;\n\n    this.defaultCollisionWidth = .75 * this.blockWidth;\n    this.collisionWidth = this.defaultCollisionWidth;\n    this.newBlockWidth = 0;\n\n    window.game = this;\n  }\n\n  reset(size, startSequence) {\n    this.size = parseInt(size);\n    this.over = false;\n    this.startSequence = parseInt(startSequence);\n    this.sequence = FIBONACCI.slice(this.startSequence);\n    this.blockWidth = (this.boardWidth - (this.size + 1) * this.borderWidth)/size;\n    this.board = this.setupBoard();\n    this.ctx.clearRect(0, 0, this.boardWidth, this.boardWidth);\n    this.run();\n  }\n\n\n  run(){\n    this.populateSidebar();\n    this.startAnimation();\n    this.addRandomBlock();\n    this.addRandomBlock();\n  }\n\n  render() {\n    this.ctx.clearRect(0, 0, this.boardWidth, this.boardWidth);\n    this.renderBoard();\n    this.renderBlocks();\n    console.log(\"render\");\n  }\n\n  populateSidebar() {\n    const $sidebar = $('.sequence-tracker');\n    $sidebar.empty();\n    let sidebarValues = this.sequence;\n\n    sidebarValues.forEach((num) => {\n      let $fibNum = $(\"<div></div>\");\n      $fibNum.text(num);\n      $fibNum.addClass(\"fibNum_\" + num.toString());\n      if (num <= 1) $fibNum.addClass(\"highlighted\");\n      $sidebar.append($fibNum);\n    });\n  }\n\n  updateSidebar() {\n    let max = this.maxBoxValue();\n    this.sequence.forEach((num) => {\n      let $num = $('.fibNum_' + num.toString());\n      if (num <= max) {\n        $num.addClass(\"highlighted\");\n      }\n    });\n\n  }\n\n  maxBoxValue() {\n    let max = 1;\n    this.board.forEach((row) => {\n      row.forEach((block) => {\n        if (block.value > max) max = block.value;\n      });\n    });\n    return max;\n  }\n\n  won() {\n    if (this.maxBoxValue() === 144) {\n      this.renderWon();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  gameover() {\n    if (this.won()) return true;\n    for(let i = 0; i < this.size; i++) {\n      for(let j = 0; j < this.size; j++) {\n        if(this.positionEmpty(i,j)) {\n          return false;\n        }\n      }\n    }\n    this.renderLost();\n    return true;\n  }\n\n  renderLost() {\n    this.ctx.clearRect(0, 0, this.boardWidth, this.boardWidth);\n    this.ctx.rect(0, 0, this.boardWidth, this.boardWidth);\n    this.ctx.fillStyle = 'red';\n    this.ctx.fill();\n    this.ctx.font = \"50px Arial\";\n    this.ctx.fillStyle = 'white';\n    this.ctx.fillText(\"YOU LOSE!!\", (this.boardWidth/2) - (140), (this.boardWidth/2) + (0));\n    this.ctx.closePath();\n  }\n\n  renderWon() {\n    this.ctx.clearRect(0, 0, this.boardWidth, this.boardWidth);\n    this.ctx.rect(0, 0, this.boardWidth, this.boardWidth);\n    this.ctx.fillStyle = 'blue';\n    this.ctx.fill();\n    this.ctx.font = \"50px Arial\";\n    this.ctx.fillStyle = 'white';\n    this.ctx.fillText(\"YOU WIN!!\", (this.boardWidth/2) - (140), (this.boardWidth/2) + (0));\n    this.ctx.closePath();\n  }\n\n  setupBoard() {\n    let matrix = [];\n    let row = [];\n    for(let i = 0; i < this.size; i++) {\n      for(let j = 0; j < this.size; j++) {\n        const block = new Block(-1);\n        row.push(block);\n      }\n      matrix.push(row);\n      row = [];\n    }\n    return matrix;\n  }\n\n  renderBoard(){\n    this.ctx.rect(0, 0, this.boardWidth, this.boardWidth);\n    this.ctx.fillStyle = '#b7b8b6';\n    this.ctx.fill();\n    this.ctx.closePath();\n  }\n\n  renderBlocks(){\n    this.updateSidebar();\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        let block = this.board[i][j];\n        this.renderBlock(block, i, j);\n      }\n    }\n  }\n\n  renderBlankBoard(){\n    this.renderBoard();\n    let block = new Block(-1);\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        this.renderBlock(block, i, j);\n      }\n    }\n  }\n\n  printBoardToConsole() {\n    // let arr = [];\n    let str = \"\";\n    for (let i = 0; i < this.size; i++) {\n      str = i + \" \";\n      for (let j = 0; j < this.size; j++) {\n        if (this.board[i][j].value === -1) {\n          str += \"O \";\n        } else {\n          str += this.board[i][j].value + \" \";\n        }\n      }\n      console.log(str);\n    }\n  }\n\n  renderBlock(block, row, col, width = this.blockWidth) {\n    let x = col * this.blockWidth + this.borderWidth * (col + 1) + (this.blockWidth - width) / 2;\n    let y = row * this.blockWidth + this.borderWidth * (row + 1) + (this.blockWidth - width) / 2;\n    this.ctx.beginPath();\n\n    this.ctx.rect(x, y, width, width);\n    this.ctx.fillStyle = block.getColor();\n\n    this.ctx.fill();\n    if (block.value > -1) {\n      let fontSize = width/2;\n      this.ctx.font = (fontSize).toString() + \"px Arial\";\n      this.ctx.fillStyle = 'white';\n      if(block.value >= 100) {\n        this.ctx.fillText(block.value, x + (width/2) - (width/2.5), y + (width/2) + (width/7));\n      } else if (block.value >= 10) {\n        this.ctx.fillText(block.value, x + (width/2) - (width/4), y + (width/2) + (width/7));\n      } else {\n        this.ctx.fillText(block.value, x + (width/2) - (width/7), y + (width/2) + (width/7));\n      }\n    }\n    this.ctx.closePath();\n  }\n\n  addRandomBlock(){\n    if (this.gameover()) return;\n    let positionFull = true;\n    while(positionFull) {\n      let x = this.randomInt(0, this.size - 1);\n      let y = this.randomInt(0, this.size - 1);\n      let value = 1;\n      if (this.startSequence === 0) {\n        value = (Math.random() < .25 ? 0 : 1);\n      }\n      if (this.positionEmpty(x,y)) {\n        this.board[x][y].value = value;\n        this.board[x][y].isNew = true;\n        positionFull = false;\n      }\n    }\n    this.randomAnimation = true;\n  }\n\n  renderRandomBlock () {\n    let finishedAddingNew = true;\n    this.renderBlankBoard();\n\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n\n        let block = this.board[i][j];\n        if (block.value > -1) {\n\n          if (this.newBlockWidth < this.blockWidth) {\n            finishedAddingNew = false;\n          } else {\n            block.isNew = false;\n          }\n\n          if (block.isNew) {\n            this.renderBlock(block, i, j, this.newBlockWidth);\n          } else {\n            this.renderBlock(block, i, j);\n          }\n          this.newBlockWidth += .75;\n        }\n      }\n    }\n\n    if (finishedAddingNew) {\n      this.newBlockWidth = 0;\n      this.allowUserInput = true;\n    }\n  }\n\n  randomInt(a,b) {\n    return Math.floor(Math.random() * (b - a + 1)) + a;\n  }\n\n  positionEmpty(x,y) {\n    return (this.board[x][y].value === -1 ? true: false);\n  }\n\n  startAnimation(shift) {\n    console.log(\"start animation\");\n    this.allowUserInput = false;\n\n    let animation = setInterval(() => {\n      if(this.allowUserInput) {\n        console.log(\"stop animation\");\n        clearInterval(animation);\n        this.render();\n        this.printBoardToConsole();\n      }\n\n      if(this.slidingAnimation) {\n        this.renderSliding(shift);\n      }\n      else if (this.collisionAnimation) {\n        this.renderCollision(shift);\n      }\n      else if (this.randomAnimation) {\n        this.renderRandomBlock();\n      }\n    }, 5);\n  }\n\n  moveBlocks(direction) {\n    // this.allowUserInput = false;\n    console.log('this is the dirction: ', direction);\n    let shift = [1,0];\n    switch(direction) {\n      case 'left':\n        shift = [0, -1];\n        break;\n      case 'right':\n        shift = [0, 1];\n        break;\n      case 'up':\n        shift = [-1, 0];\n        break;\n      case 'down':\n        shift = [1, 0];\n        break;\n    }\n    console.log(shift);\n    this.slideBlocks(shift);\n    this.startAnimation(shift);\n  }\n\n  slideBlocks(shift) {\n    let emptyCount = 0;\n    let row, col;\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        if(shift[0] === 0){\n          row = i;\n          col = (shift[1] === 1 ? this.size - j - 1 : j);\n        } else {\n          col = i;\n          row = (shift[0] === 1 ? this.size - j - 1 : j);\n        }\n        if(this.positionEmpty(row,col)) {\n          emptyCount++;\n        } else if (emptyCount !== 0) {\n          this.board[row][col].positionShift = emptyCount;\n          this.board[row + shift[0] * emptyCount][col + shift[1] * emptyCount] = this.board[row][col];\n          this.board[row][col] = new Block(-1);\n        }\n      }\n      emptyCount = 0;\n    }\n    this.slidingAnimation = true;\n  }\n\n  renderSliding(shift) {\n    let finishedSliding = true;\n    this.renderBlankBoard();\n\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n\n        let block = this.board[i][j];\n        if (block.value > -1) {\n          let row = i - (block.positionShift * shift[0]);\n          let col = j - (block.positionShift * shift[1]);\n\n          if (block.positionShift > 0) {\n            finishedSliding = false;\n          } else {\n            block.positionShift = 0;\n            row = i;\n            col = j;\n          }\n          this.renderBlock(block, row, col);\n          block.positionShift -= .1;\n        }\n      }\n    }\n    if (finishedSliding) {\n      this.slidingAnimation = false;\n      this.consolidateBlocks(shift);\n    }\n  }\n\n  consolidateBlocks(shift) {\n    let consolidated = false;\n    let skipConsolidated = true;\n\n    let row, col;\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size - 1; j++) {\n        if(shift[0] === 0){\n          row = i;\n          col = (shift[1] === 1 ? this.size - j - 1 : j);\n        } else {\n          col = i;\n          row = (shift[0] === 1 ? this.size - j - 1 : j);\n        }\n        let block = this.board[row][col];\n        let nextBlock = this.board[row - shift[0]][col - shift[1]];\n\n        if ( this.positionEmpty(row,col) && skipConsolidated ) {\n          break; //breaks out of inner for loop when nothing to consolidate\n        } else if (!skipConsolidated) {\n          skipConsolidated  = true;\n        } else {\n          let nextFib = this.nextFib(block.value, nextBlock.value);\n          if (nextFib !== -1) {\n            block.value = nextFib;\n            block.isNew = true;\n            nextBlock.value = -1;\n            skipConsolidated  = false;\n            consolidated = true;\n          }\n        }\n      }\n    }\n\n    if(consolidated) {\n      this.collisionAnimation = true;\n    } else {\n      this.collisionAnimation = false;\n      this.addRandomBlock();\n    }\n  }\n\n  renderCollision(shift) {\n    console.log(\"renderColl method\");\n    let finishedColliding = true;\n    this.renderBlankBoard();\n\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n\n        let block = this.board[i][j];\n        if (block.value > -1) {\n\n          if (this.collisionWidth < this.blockWidth * 1.3) {\n            finishedColliding = false;\n          } else {\n            block.isNew = false;\n          }\n\n          if (block.isNew) {\n            this.renderBlock(block, i, j, this.collisionWidth);\n          } else {\n            this.renderBlock(block, i, j);\n          }\n          this.collisionWidth += .5;\n        }\n      }\n    }\n\n    if (finishedColliding) {\n      this.collisionWidth = this.defaultCollisionWidth;\n      this.collisionAnimation = false;\n      this.slideBlocks(shift);\n      console.log('finishColl = true');\n    }\n  }\n\n  nextFib(max,min) {\n    let returnValue = -1;\n    this.sequence.forEach((num, idx) => {\n      if(num === min && this.sequence[idx + 1] === max) {\n        returnValue = min + max;\n      }\n    });\n    return returnValue;\n  }\n\n}\nmodule.exports = Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/game.js\n// module id = 0\n// module chunks = 0","class Block {\n  constructor(value) {\n    this.value = value;\n    this.positionShift = 0;\n    this.isNew = false;\n    // this.row = row;\n    // this.col = col;\n  }\n\n  getColor() {\n    switch (this.value) {\n      case -1:\n        return \"#b2a7a7\"; //#f1f1f2\n      case 0:\n        return \"#c4dfe6\";\n      case 1:\n        return \"#66a5ad\";\n      case 2:\n        return \"#75b1a9\";\n      case 3:\n        return \"#2c7873\";\n      case 5:\n        return \"#1995ad\";\n      case 8:\n        return \"#07575b\";\n      case 13:\n        return \"#6e6702\";\n      case 21:\n        return \"#86ac41\";\n      case 34:\n        return \"#b3c100\";\n      case 55:\n        return \"#d9b44a\";\n      case 89:\n        return \"#ffd64d\";\n      case 144:\n        return \"#cb6318\";\n    }\n  }\n}\n\nmodule.exports = Block;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/block.js\n// module id = 1\n// module chunks = 0","const Game = require(\"./game\");\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n  const gameboard = document.getElementById(\"canvas\");\n  let ctx = gameboard.getContext('2d');\n  let boardWidth = gameboard.width;\n\n  let sequencePicker = document.getElementById('sequence');\n  let sizePicker = document.getElementById('board-size');\n  let restartButton = document.getElementById(\"restart-button\");\n\n  // sequencePicker.onchange = newGame;\n  // sizePicker.onchange = newGame;\n  restartButton.onclick = newGame;\n\n  let size = sizePicker.value;\n  let sequence = sequencePicker.value;\n\n  let game = new Game(size, sequence, ctx, boardWidth);\n  game.run();\n\n  function newGame() {\n    size = sizePicker.value;\n    sequence = sequencePicker.value;\n    game.reset(size, sequence);\n    window.size = size;\n  }\n\n  window.addEventListener('keydown', (e) => {\n    console.log(\"key down\");\n    if(!game.gameover() && game.allowUserInput) {\n      console.log(\"allowUserInput\");\n      if(e.key === 'ArrowLeft') {\n        game.moveBlocks('left');\n        console.log(\"left arrow\");\n        // game.updateSidebar();\n      } else if(e.key === 'ArrowUp') {\n        game.moveBlocks('up');\n        // game.updateSidebar();\n      } else if(e.key === 'ArrowRight') {\n        game.moveBlocks('right');\n        // game.updateSidebar();\n      } else if(e.key === 'ArrowDown') {\n        game.moveBlocks('down');\n        // game.updateSidebar();\n      }\n    }\n  });\n\n  const $instructions = $('.instructions-container');\n\n\n  let instructionsButton = document.getElementById(\"instructions-button\");\n  let closeInstructionsButton = document.getElementById(\"close-button\");\n\n  instructionsButton.onclick = showInstructions;\n  closeInstructionsButton.onclick = hideInstructions;\n\n  function showInstructions() {\n    $instructions.removeClass(\"hide-instructions\");\n    $instructions.addClass(\"show-instructions\");\n  }\n\n  function hideInstructions() {\n    $instructions.removeClass(\"show-instructions\");\n    $instructions.addClass(\"hide-instructions\");\n  }\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/main.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}