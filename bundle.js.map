{"version":3,"sources":["webpack:///webpack/bootstrap e598731648d27ca1bf8d","webpack:///./js/main.js","webpack:///./js/game.js","webpack:///./js/block.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;;AAEH;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC;;;;;;;AClED;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;;AAEA;AACA;AACA,mBAAkB,eAAe;AACjC,qBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAkB,eAAe;AACjC,qBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,eAAe;AAClC,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,eAAe;AAClC,kCAAiC,QAAQ;AACzC;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAmB,eAAe;AAClC,kCAAiC,OAAO;AACxC;AACA,iBAAgB;AAChB,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA,oBAAmB,eAAe;AAClC,sBAAqB,eAAe;AACpC;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAmB,eAAe;AAClC,sBAAqB,mBAAmB;AACxC;AACA,iBAAgB;AAChB,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;;;;AAKA;AACA;AACA,sBAAqB,iBAAiB;AACtC,oCAAmC,UAAU;AAC7C;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAqB,iBAAiB;AACtC,oCAAmC,SAAS;AAC5C;AACA,iBAAgB;AAChB,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA,sBAAqB,iBAAiB;AACtC,wBAAuB,iBAAiB;AACxC;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAqB,iBAAiB;AACtC,wBAAuB,qBAAqB;AAC5C;AACA,iBAAgB;AAChB,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;;;;;;ACxXA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e598731648d27ca1bf8d","const Game = require(\"./game\");\n// const Instructions = require(\"./instructions\");\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n  const gameboard = document.getElementById(\"canvas\");\n  let ctx = gameboard.getContext('2d');\n  let boardWidth = gameboard.width;\n\n  let sequencePicker = document.getElementById('sequence');\n  let sizePicker = document.getElementById('board-size');\n  let restartButton = document.getElementById(\"restart-button\");\n\n  // sequencePicker.onchange = newGame;\n  // sizePicker.onchange = newGame;\n  restartButton.onclick = newGame;\n\n  let size = sizePicker.value;\n  let sequence = sequencePicker.value;\n\n  let game = new Game(size, sequence, ctx, boardWidth);\n  game.run();\n\n  function newGame() {\n    size = sizePicker.value;\n    sequence = sequencePicker.value;\n    game.reset(size, sequence);\n    window.size = size;\n  }\n\n  window.addEventListener('keydown', (e) => {\n    if(!game.over) {\n      if(e.key === 'ArrowLeft') {\n        game.moveBlocks('left');\n        // game.updateSidebar();\n      } else if(e.key === 'ArrowUp') {\n        game.moveBlocks('up');\n        // game.updateSidebar();\n      } else if(e.key === 'ArrowRight') {\n        game.moveBlocks('right');\n        // game.updateSidebar();\n      } else if(e.key === 'ArrowDown') {\n        game.moveBlocks('down');\n        // game.updateSidebar();\n      }\n    }\n  });\n\n  const $instructions = $('.instructions-container');\n\n\n  let instructionsButton = document.getElementById(\"instructions-button\");\n  let closeInstructionsButton = document.getElementById(\"close-button\");\n\n  instructionsButton.onclick = showInstructions;\n  closeInstructionsButton.onclick = hideInstructions;\n\n  function showInstructions() {\n    $instructions.removeClass(\"hide-instructions\");\n    $instructions.addClass(\"show-instructions\");\n  }\n\n  function hideInstructions() {\n    $instructions.removeClass(\"show-instructions\");\n    $instructions.addClass(\"hide-instructions\");\n  }\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/main.js\n// module id = 0\n// module chunks = 0","const Block = require(\"./block\");\n\nconst FIBONACCI = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];\n\nclass Game {\n  constructor(size, startSequence, ctx, boardWidth) {\n    this.size = parseInt(size);\n    this.startSequence = parseInt(startSequence);\n    this.over = false;\n    this.ctx = ctx;\n    this.boardWidth = boardWidth;\n    this.borderWidth = 5;\n    this.blockWidth = (boardWidth - (this.size + 1) * this.borderWidth)/size;\n    this.board = this.setupBoard();\n    this.sequence = FIBONACCI.slice(this.startSequence);\n  }\n\n  reset(size, startSequence) {\n    this.size = parseInt(size);\n    this.over = false;\n    this.startSequence = parseInt(startSequence);\n    this.sequence = FIBONACCI.slice(this.startSequence);\n    this.blockWidth = (this.boardWidth - (this.size + 1) * this.borderWidth)/size;\n    this.board = this.setupBoard();\n    this.ctx.clearRect(0, 0, this.boardWidth, this.boardWidth);\n    this.run();\n  }\n\n\n  run(){\n    this.populateSidebar();\n    this.renderBoard();\n    this.addRandomBlock();\n    this.addRandomBlock();\n    this.renderBlocks();\n  }\n\n  populateSidebar() {\n    const $sidebar = $('.sequence-tracker');\n    $sidebar.empty();\n    let sidebarValues = this.sequence;\n    // if (this.startSequence === 1) {\n    //   sidebarValues = sidebarValues.slice(1);\n    // }\n\n    sidebarValues.forEach((num) => {\n      let $fibNum = $(\"<div></div>\");\n      $fibNum.text(num);\n      $fibNum.addClass(\"fibNum_\" + num.toString());\n      if (num <= 1) $fibNum.addClass(\"highlighted\");\n      $sidebar.append($fibNum);\n    });\n  }\n\n  updateSidebar() {\n    let max = this.maxBoxValue();\n    this.sequence.forEach((num) => {\n      let $num = $('.fibNum_' + num.toString());\n      if (num <= max) {\n        $num.addClass(\"highlighted\");\n      }\n    });\n\n  }\n\n  maxBoxValue() {\n    let max = 1;\n    this.board.forEach((row) => {\n      row.forEach((block) => {\n        if (block.value > max) max = block.value;\n      });\n    });\n    return max;\n  }\n\n  // TODO need to update\n  gameover() {\n    for(let i = 0; i < this.size; i++) {\n      for(let j = 0; j < this.size; j++) {\n        if(this.positionEmpty(i,j)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  setupBoard() {\n    let matrix = [];\n    let row = [];\n    for(let i = 0; i < this.size; i++) {\n      for(let j = 0; j < this.size; j++) {\n        const block = new Block(-1, i, j);\n        row.push(block);\n      }\n      matrix.push(row);\n      row = [];\n    }\n    return matrix;\n  }\n\n  renderBoard(){\n    this.ctx.clearRect(0, 0, this.boardWidth, this.boardWidth);\n    this.ctx.rect(0, 0, this.boardWidth, this.boardWidth);\n    this.ctx.fillStyle = '#b7b8b6';\n    this.ctx.fill();\n    this.ctx.closePath();\n  }\n\n  renderBlocks(){\n    this.updateSidebar();\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        this.ctx.beginPath();\n        let block = this.board[i][j];\n        let xOffset = this.borderWidth * (j + 1);\n        let yOffset = this.borderWidth * (i + 1);\n        let x = j * this.blockWidth + xOffset;\n        let y = i * this.blockWidth + yOffset;\n\n        this.ctx.rect(x, y, this.blockWidth, this.blockWidth);\n        this.ctx.fillStyle = block.getColor();\n\n        this.ctx.fill();\n        if (block.value > -1) {\n          this.ctx.font = \"20px Arial\";\n          this.ctx.fillStyle = 'white';\n          this.ctx.fillText(block.value, x + (this.blockWidth/2), y + (this.blockWidth/2));\n        }\n        this.ctx.closePath();\n\n      }\n    }\n  }\n\n  addRandomBlock(){\n    let positionFull = true;\n    while(positionFull) {\n      let x = this.randomInt(0, this.size - 1);\n      let y = this.randomInt(0, this.size - 1);\n      let value = 1;\n      if (this.startSequence === 0) {\n        value = (Math.random() < .25 ? 0 : 1);\n      }\n      if (this.positionEmpty(x,y)) {\n        this.board[x][y].value = value;\n        positionFull = false;\n      }\n    }\n  }\n\n  randomInt(a,b) {\n    return Math.floor(Math.random() * (b - a + 1)) + a;\n  }\n\n  positionEmpty(x,y) {\n    return (this.board[x][y].value === -1 ? true: false);\n  }\n\n\n  moveBlocks(direction) {\n    switch(direction) {\n      case 'left':\n        return this.slideBlocksLeft();\n      case 'right':\n        return this.slideBlocksRight();\n      case 'up':\n        return this.slideBlocksUp();\n      case 'down':\n        return this.slideBlocksDown();\n    }\n  }\n\n  slideBlocksRight(){\n    let emptyCount = 0;\n    for (let i = 0; i < this.size; i++) {\n      for (let j = this.size - 1; j >= 0; j--) {\n        if(this.positionEmpty(i,j)) {\n          emptyCount++;\n        } else if (emptyCount !== 0) {\n          this.board[i][j + emptyCount] = this.board[i][j];\n          this.board[i][j] = new Block(-1, i, j);\n        }\n      }\n      emptyCount = 0;\n    }\n\n    let consolidated = false;\n    let skipConsolidated = true;\n\n    for (let i = 0; i < this.size; i++) {\n      for (let j = this.size - 1; j > 0; j--) {\n        if ( this.positionEmpty(i,j) && skipConsolidated ) {\n          break; //breaks out of inner for loop when nothing to consolidate\n        } else if (!skipConsolidated) {\n          skipConsolidated  = true;\n        } else {\n          let nextFib = this.nextFib(this.board[i][j].value, this.board[i][j-1].value);\n          if (nextFib !== -1) {\n            this.board[i][j].value = nextFib;\n            this.board[i][j-1].value = -1;\n            skipConsolidated  = false;\n            consolidated = true;\n          }\n        }\n      }\n    }\n    this.renderBlocks();\n    if(consolidated) {\n      this.slideBlocksRight();\n    } else {\n      this.renderBlocks();\n      setTimeout(() => {\n        this.addRandomBlock();\n        this.renderBlocks();\n      }, 200);\n    }\n  }\n\n  slideBlocksLeft(){\n    let emptyCount = 0;\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        if(this.positionEmpty(i,j)) {\n          emptyCount++;\n        } else if (emptyCount !== 0) {\n          this.board[i][j - emptyCount] = this.board[i][j];\n          this.board[i][j] = new Block(-1, i, j);\n        }\n      }\n      emptyCount = 0;\n    }\n\n    let consolidated = false;\n    let skipConsolidated = true;\n\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size - 1; j++) {\n        if ( this.positionEmpty(i,j) && skipConsolidated ) {\n          break; //breaks out of inner for loop when nothing to consolidate\n        } else if (!skipConsolidated) {\n          skipConsolidated  = true;\n        } else {\n          let nextFib = this.nextFib(this.board[i][j].value, this.board[i][j+1].value);\n          if (nextFib !== -1) {\n            this.board[i][j].value = nextFib;\n            this.board[i][j+1].value = -1;\n            skipConsolidated  = false;\n            consolidated = true;\n          }\n        }\n      }\n    }\n    this.renderBlocks();\n    if(consolidated) {\n      this.slideBlocksLeft();\n    } else {\n      this.renderBlocks();\n      setTimeout(() => {\n        this.addRandomBlock();\n        this.renderBlocks();\n      }, 200);\n    }\n  }\n\n  nextFib(max,min) {\n    // if (min > max) {\n    //   let temp = min;\n    //   min = max;\n    //   max = temp;\n    // }\n    let returnValue = -1;\n    this.sequence.forEach((num, idx) => {\n      if(num === min && this.sequence[idx + 1] === max) {\n        returnValue = min + max;\n      }\n    });\n    return returnValue;\n  }\n\n\n\n\n  slideBlocksDown(){\n    let emptyCount = 0;\n    for (let col = 0; col < this.size; col++) {\n      for (let row = this.size - 1; row >= 0; row--) {\n        if(this.positionEmpty(row,col)) {\n          emptyCount++;\n        } else if (emptyCount !== 0) {\n          this.board[row + emptyCount][col] = this.board[row][col];\n          this.board[row][col] = new Block(-1, row, col);\n        }\n      }\n      emptyCount = 0;\n    }\n\n    let consolidated = false;\n    let skipConsolidated = true;\n\n    for (let col = 0; col < this.size; col++) {\n      for (let row = this.size - 1; row > 0; row--) {\n        if ( this.positionEmpty(row,col) && skipConsolidated ) {\n          break; //breaks out of inner for loop when nothing to consolidate\n        } else if (!skipConsolidated) {\n          skipConsolidated  = true;\n        } else {\n          let nextFib = this.nextFib(this.board[row][col].value, this.board[row - 1][col].value);\n          if (nextFib !== -1) {\n            this.board[row][col].value = nextFib;\n            this.board[row - 1][col].value = -1;\n            skipConsolidated  = false;\n            consolidated = true;\n          }\n        }\n      }\n    }\n    this.renderBlocks();\n    if(consolidated) {\n      this.slideBlocksDown();\n    } else {\n      this.renderBlocks();\n      setTimeout(() => {\n        this.addRandomBlock();\n        this.renderBlocks();\n      }, 200);\n    }\n  }\n\n  slideBlocksUp(){\n    let emptyCount = 0;\n    for (let col = 0; col < this.size; col++) {\n      for (let row = 0; row < this.size; row++) {\n        if(this.positionEmpty(row,col)) {\n          emptyCount++;\n        } else if (emptyCount !== 0) {\n          this.board[row - emptyCount][col] = this.board[row][col];\n          this.board[row][col] = new Block(-1, row, col);\n        }\n      }\n      emptyCount = 0;\n    }\n\n    let consolidated = false;\n    let skipConsolidated = true;\n\n    for (let col = 0; col < this.size; col++) {\n      for (let row = 0; row < this.size - 1; row++) {\n        if ( this.positionEmpty(row,col) && skipConsolidated ) {\n          break; //breaks out of inner for loop when nothing to consolidate\n        } else if (!skipConsolidated) {\n          skipConsolidated  = true;\n        } else  {\n          let nextFib = this.nextFib(this.board[row][col].value, this.board[row + 1][col].value);\n          if (nextFib !== -1) {\n            this.board[row][col].value = nextFib;\n            this.board[row + 1][col].value = -1;\n            skipConsolidated  = false;\n            consolidated = true;\n          }\n        }\n      }\n    }\n    this.renderBlocks();\n    if(consolidated) {\n      this.slideBlocksUp();\n    } else {\n      this.renderBlocks();\n      setTimeout(() => {\n        this.addRandomBlock();\n        this.renderBlocks();\n      }, 200);\n    }\n  }\n}\n\nmodule.exports = Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/game.js\n// module id = 1\n// module chunks = 0","class Block {\n  constructor(value, row, col) {\n    this.value = value;\n    this.row = row;\n    this.col = col;\n  }\n\n\n\n  getColor() {\n    switch (this.value) {\n      case -1:\n        return \"#f1f1f2\";\n      case 0:\n        return \"#c4dfe6\";\n      case 1:\n        return \"#66a5ad\";\n      case 2:\n        return \"#75b1a9\";\n      case 3:\n        return \"#2c7873\";\n      case 5:\n        return \"#1995ad\";\n      case 8:\n        return \"#07575b\";\n      case 13:\n        return \"#6e6702\";\n      case 21:\n        return \"#86ac41\";\n      case 34:\n        return \"#b3c100\";\n      case 55:\n        return \"#d9b44a\";\n      case 89:\n        return \"#ffd64d\";\n      case 144:\n        return \"#cb6318\";\n    }\n  }\n}\n\nmodule.exports = Block;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/block.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}